<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <meta name="author" content="Trevor Perrin (noise@trevp.net)" />
  <meta name="date" content="2018-11-17" />
  <title>KEM-based Hybrid Forward Secrecy for Noise</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="spec_markdown.css" type="text/css" />
</head>
<body>
<div id="header">
<h1 class="title">KEM-based Hybrid Forward Secrecy for Noise</h1>
<b>Author:</b> Trevor Perrin (noise@trevp.net)<br/>
<b>Revision:</b> 1<br/>
<b>Date:</b> 2018-11-17<br/>
<b>Status:</b> unofficial/unstable<br/>
<b>PDF:</b> <a href="noise_hfs.pdf">noise_hfs.pdf</a><br/>
</div>
<div id="TOC">
<h2 class="toc">Table of Contents</h2>
<ul>
<li><a href="#introduction">1. Introduction</a></li>
<li><a href="#overview">2. Overview</a></li>
<li><a href="#kem-functions">3. KEM functions</a></li>
<li><a href="#kem-tokens">4. KEM tokens</a></li>
<li><a href="#the-hfs-modifier">5. The <code>&quot;hfs&quot;</code> modifier</a></li>
<li><a href="#selecting-postquantum-kems">6. Selecting postquantum KEMs</a></li>
<li><a href="#security-considerations">7. Security considerations</a></li>
<li><a href="#rationales">6. Rationales</a></li>
<li><a href="#ipr">7. IPR</a></li>
<li><a href="#acknowledgements">8. Acknowledgements</a></li>
</ul>
</div>
<h1 id="introduction">1. Introduction</h1>
<p>This document describes the <code>&quot;hfs&quot;</code> modifier for Noise. This modifier adds KEM-based hybrid forward secrecy to a Noise handshake.</p>
<h1 id="overview">2. Overview</h1>
<p>Noise handshakes depend on some Diffie-Hellman function (usually an Elliptic Curve Diffie-Hellman function such as X25519). If this function is broken by future cryptanalysis then previously-recorded traffic could be decrypted.</p>
<p>To hedge against this possibility, one could use a different public-key algorithm to add <em>hybrid forward secrecy</em>, so that both this new algorithm and the DH algorithm would have to be broken to decrypt old traffic. At time of writing, there's some interest in using <em>post-quantum cryptographic algorithms</em> which might be secure against a <em>quantum computer</em> which could break DH.</p>
<p>These post-quantum algorithms often come in the form of a <strong>KEM</strong>, or Key Encapsulation Mechanism. Unlike a DH algorithm where both parties exchange public keys in any order, a KEM algorithm requires one party to send a ciphertext based on the other party's public key.</p>
<p>This document describes a Noise handshake modifer (<code>&quot;hfs&quot;</code>) that adds hybrid forward secrecy using a KEM algorithm.</p>
<h1 id="kem-functions">3. KEM functions</h1>
<p><strong>KEM functions</strong> are similar to DH functions, but require an exchange of a public key followed by a ciphertext, rather than an exchange of public keys.</p>
<p>The signature for these functions is defined below.</p>
<ul>
<li><p><strong><code>GENERATE_KEM_KEYPAIR()</code></strong>: Generates a new KEM key pair. A KEM key pair consists of <code>public_key</code> and <code>private_key</code> elements. A <code>public_key</code> represents an encoding of a KEM public key into a byte sequence of length <code>KEMPUBLICKEYLEN</code>. The <code>public_key</code> encoding details are specific to each set of KEM functions.</p></li>
<li><p><strong><code>GENERATE_KEM_CIPHERTEXT(public_key)</code></strong>: Generates both a KEM ciphertext and a KEM output based on the recipient's public key. A <code>ciphertext</code> represents an encoding of a KEM ciphertext into a byte sequence of length <code>KEMCIPHERTEXTLEN</code>. A <code>kem_output</code> represents an encoding of a KEM output into a byte sequence of length <code>KEMOUTPUTLEN</code>. The <code>ciphertext</code> and <code>kem_output</code> encoding details are specific to each set of KEM functions.</p></li>
<li><p><strong><code>KEM(key_pair, ciphertext)</code></strong>: Performs a KEM calculation between the private key in <code>key_pair</code> and the <code>ciphertext</code> and returns a KEM output byte sequence of length <code>KEMOUTPUTLEN</code>. The <code>kem_output</code> matches the value that was generated by <code>GENERATE_KEM_CIPHERTEXT()</code>.</p></li>
<li><p><strong><code>KEMPUBLICKEYLEN</code></strong> = A constant specifying the size in bytes of KEM public keys.</p></li>
<li><p><strong><code>KEMCIPHERTEXTLEN</code></strong> = A constant specifying the size in bytes of KEM ciphertexts.</p></li>
<li><p><strong><code>KEMOUTPUTLEN</code></strong> = A constant specifying the size in bytes of KEM outputs.</p></li>
</ul>
<h1 id="kem-tokens">4. KEM tokens</h1>
<p>Two new tokens are introduced by this document:</p>
<ul>
<li><p><strong><code>&quot;e1&quot;</code></strong> = This token directs the sender to call <code>GENERATE_KEM_KEYPAIR()</code>. The resulting KEM public key is transferred to the recipient as if it was a static DH public key (i.e. using <code>EncryptAndHash()</code> if a key is available).</p></li>
<li><p><strong><code>&quot;ekem1&quot;</code></strong> = This token directs the sender to call <code>GENERATE_KEM_CIPHERTEXT()</code> using a previously received KEM public key. The resulting KEM ciphertext is transferred to the recipient as if it was a static DH public key (i.e. using <code>EncryptAndHash()</code> if a key is available). On receiving this token, the recipient will call <code>KEM(key_pair, ciphertext)</code> to derive the same <code>kem_output</code> as the sender possesses. On sending or receiving this token, the parties call <code>MixKey(kem_output)</code>.</p></li>
</ul>
<h1 id="the-hfs-modifier">5. The <code>&quot;hfs&quot;</code> modifier</h1>
<p>The <code>&quot;hfs&quot;</code> pattern modifier adds an <code>&quot;e1&quot;</code> token directly following the first occurrence of <code>&quot;e&quot;</code>, unless there is a DH operation in this same message, in which case the <code>&quot;hfs&quot;</code> token is placed directly after this DH (so that the public key will be encrypted).</p>
<p>The <code>&quot;hfs&quot;</code> modifier also adds an <code>&quot;ekem1&quot;</code> token directly following the first occurrence of <code>&quot;ee&quot;</code>.</p>
<p>When the <code>&quot;hfs&quot;</code> modifier is used, the DH name section must contain a KEM algorithm name directly following the DH algorithm name, separated by a plus sign.</p>
<p>The table below lists some example unmodified patterns on the left, and some HFS patterns on the right:</p>

<table>
<colgroup>
<col width="45%" />
<col width="54%" />
</colgroup>
<tbody>
<tr class="odd">
<td><pre><code>NN:
  -&gt; e
  &lt;- e, ee</code></pre></td>
<td><pre><code>NNhfs:
  -&gt; e, e1
  &lt;- e, ee, ekem1</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>NK:
  &lt;- s
  ...
  -&gt; e, es
  &lt;- e, ee</code></pre></td>
<td><pre><code>NKhfs:
  &lt;- s
  ...
  -&gt; e, es, e1
  &lt;- e, ee, ekem1</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>NX:
  -&gt; e
  &lt;- e, ee, s, es</code></pre></td>
<td><pre><code> NXhfs:
   -&gt; e, e1
   &lt;- e, ee, ekem1, s, es</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XN:
  -&gt; e
  &lt;- e, ee
  -&gt; s, se</code></pre></td>
<td><pre><code> XNhfs:
   -&gt; e, e1
   &lt;- e, ee, ekem1
   -&gt; s, se</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>XK:
  &lt;- s
  ...
  -&gt; e, es
  &lt;- e, ee
  -&gt; s, se</code></pre></td>
<td><pre><code> XKhfs:
   &lt;- s
   ...
   -&gt; e, es, e1
   &lt;- e, ee, ekem1
   -&gt; s, se</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>XX:
  -&gt; e
  &lt;- e, ee, s, es
  -&gt; s, se</code></pre></td>
<td><pre><code> XXhfs:
   -&gt; e, e1
   &lt;- e, ee, ekem1, s, es
   -&gt; s, se</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>KN:
  -&gt; s
  ...
  -&gt; e
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>  KNhfs:
    -&gt; s
    ...
    -&gt; e, e1
    &lt;- e, ee, ekem1, se</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>KK:
  -&gt; s
  &lt;- s
  ...
  -&gt; e, es, ss
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>  KKhfs:
    -&gt; s
    &lt;- s
    ...
    -&gt; e, e1, es, ss
    &lt;- e, ee, ekem1, se</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>KX:
  -&gt; s
  ...
  -&gt; e
  &lt;- e, ee, se, s, es</code></pre></td>
<td><pre><code>   KXhfs:
     -&gt; s
     ...
     -&gt; e, e1
     &lt;- e, ee, ekem1, se, s, es</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>IN:
  -&gt; e, s
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>   INhfs:
     -&gt; e, e1, s
     &lt;- e, ekem1, se</code></pre></td>
</tr>
<tr class="odd">
<td><pre><code>IK:
  &lt;- s
  ...
  -&gt; e, es, s, ss
  &lt;- e, ee, se</code></pre></td>
<td><pre><code>   IKhfs:
     &lt;- s
     ...
     -&gt; e, es, e1, s, ss
     &lt;- e, ee, ekem1, se</code></pre></td>
</tr>
<tr class="even">
<td><pre><code>IX:
  -&gt; e, s
  &lt;- e, ee, se, s, es</code></pre></td>
<td><pre><code>   IXhfs:
     -&gt; e, e1, s
     &lt;- e, ee, ekem1, se, s, es</code></pre></td>
</tr>
</tbody>
</table>

<h1 id="selecting-postquantum-kems">6. Selecting postquantum KEMs</h1>
<p>Postquantum algorithms are an active area of research. This document doesn't list any such algorithms, because it's unclear which algorithms will remain secure into the future (against both quantum and nonquantum attacks).</p>
<p>It's even more unclear how to balance the security strength of these algorithms against performance considerations, and even more unclear which algorithms are likely to become widely-supported.</p>
<h1 id="security-considerations">7. Security considerations</h1>
<p>Due to the Noise key derivation, even using a weak KEM algorithm will not hurt the security of the protocol. However it's difficult to assess how much security current postquantum algorithms provide.</p>
<p>Note that KEM public keys are sometimes sent in clear. If making the handshake indistinguishable from random bytes is a goal, some additional method will have to be used to obscure these values (and the DH ephemeral public keys).</p>
<h1 id="rationales">6. Rationales</h1>
<p>KEM public keys and ciphertexts are encrypted when possible because:</p>
<ul>
<li><p>This maintains consistency with current Noise behavior, which is to encrypt everything except the ephemeral DH public keys.</p></li>
<li><p>This behavior for tokens makes it easier to obscure the type of protocol being executed, since more of the handshake is encrypted.</p></li>
<li><p>This behavior might add other small security benefits (e.g. if an attacker could break some KEM public keys but not all of them, then encrypting the KEM public key might force them to perform an expensive attack against DH to determine if the KEM public key was vulnerable).</p></li>
</ul>
<h1 id="ipr">7. IPR</h1>
<p>This document is hereby placed in the public domain.</p>
<h1 id="acknowledgements">8. Acknowledgements</h1>
<p>This document draws on discussions and an earlier spec from Rhys Weatherley.</p>
</body>
</html>
